
<html>
    <head> 
    <meta charset='utf-8' />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel= "stylesheet" href="/static/css/style.css" type="text/css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/ico"/>
    <title> python-idioms </title>
    </head>
    
    <body>
            <div class="container">
	    <header>
                    <h1> <a href='/'> tangarts </a> </h1>
                    <div id="header_wrap" class="wrapper">
                    <nav id="navbar" >
                <ul class="list-none" >
                        <li><a href="/about">about</a> &centerdot;</li>
                <li><a href="/archives.html">archive</a> &centerdot;</li>
                <li><a href="/now">now</a> &centerdot;</li>
                <li><a href="mailto:nehemiahcampbell@hotmail.co.uk">contact</a></li>
                </ul> 

                    </nav>
                    </div>

            </header>  
        <main class="wrapper">

                       <hr> 


<h1> python-idioms </h1>
<div class=date>
        2020-03-22

</div>

<article><p><strong>A collection of python idioms and design patterns</strong></p>
<h3>What idioms should I use to make my code easier to read?</h3>
<p><strong>Build strings as a list and use <code>''.join</code> at the end.p</strong> </p>
<p>Join is a string method called on the separator, not the list. Calling it from
the empty string concatenates the pieces with no separator, which is a Python
quirk and rather surprising at first. This is important: <strong>string building with
+ is quadratic time instead of linear!</strong> If you learn one idiom, learn this
  one.</p>
<p><strong>Wrong:</strong> <code>for s in strings: result += s</code><br>
<strong>Right:</strong> <code>result = ''.join(strings)</code></p>
<p><strong>Use <code>in</code> wherever possible.</strong></p>
<p><strong>Use <code>if not x</code> instead of <code>if x == 0</code>.</strong></p>
<p><strong>To reverse-sort a list, use: <code>list.sort()</code> or <code>list.reverse()</code></strong></p>
<p>Catch errors rather than avoiding them to avoid cluttering your code with
special cases.  This idiom is called EAFP ('easier to ask forgiveness than
permission'), as opposed to LBYL ('look before you leap').
This often makes the code more readable. For example:</p>
<p><strong>Worse:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">#check whether int conversion will raise an error</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">isdigit</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>
<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>    <span class="c1">#too many digits for int conversion</span>
    <span class="k">return</span> <span class="kc">None</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</code></pre></div>

<p><strong>Better:</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span> <span class="c1">#int conversion failed</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>

<h3>What techniques should I use to make my code run faster?</h3>
<p>Profile before optimizing for speed: optimize for readability first</p>
<p>Build strings as a list and use <code>''.join()</code> at the end. <strong>(Super important)</strong></p>
<p><strong>Use <code>map</code> and/or <code>filter</code> to apply functions to lists.</strong></p>
<p><code>map</code> applies a function to each item in a list (technically, sequence) and
returns a list of the results.<br>
<code>filter</code> applies a function to each item in a sequence, and returns a list
containing only those items for which the function evaluated True (using the
<strong>nonzero</strong> built-in method).<br>
These functions can make code much shorter. 
They also make it much faster, since the loop takes place entirely in the C API
and never has to bind loop variables to Python objects.</p>
<p><strong>Worse:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">strings</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
</code></pre></div>

<p><strong>Better:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">strings</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div>

<h3><strong>Use function factories to create utility functions.</strong></h3>
<div class="highlight"><pre><span></span><code><span class="n">def</span> <span class="n">multiply_by_field</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="n">multiplier</span><span class="p">):</span>
    <span class="ss">&quot;&quot;&quot;Returns function that multiplies field &quot;</span><span class="n">fieldname</span><span class="ss">&quot; by multiplier.&quot;&quot;&quot;</span>
    <span class="n">def</span> <span class="n">multiplier</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">)</span> <span class="o">*</span> <span class="n">multiplier</span>
    <span class="k">return</span> <span class="n">multiplier</span>

<span class="n">triple</span> <span class="o">=</span> <span class="n">multiply_by_field</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">quadruple</span> <span class="o">=</span> <span class="n">multiply_by_field</span><span class="p">(</span><span class="s1">&#39;Count&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">halve_sum</span> <span class="o">=</span> <span class="n">multiply_by_field</span><span class="p">(</span><span class="s1">&#39;Sum&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div>

<p>python file names <code>calc_squares.py</code> over <code>calc-squares.py</code> as second cannot be
imported though single name module names are best.</p>
<h3>packagin packages</h3>
<div class="highlight"><pre><span></span><code><span class="n">package</span><span class="o">/</span>
  <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>        <span class="o">--</span> <span class="n">contains</span> <span class="n">functions</span> <span class="n">a</span><span class="p">(),</span> <span class="n">b</span><span class="p">()</span>
  <span class="n">other</span><span class="o">.</span><span class="n">py</span>           <span class="o">--</span> <span class="n">contains</span> <span class="n">function</span> <span class="n">c</span><span class="p">()</span>
  <span class="n">subdir</span><span class="o">/</span>
     <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>     <span class="o">--</span> <span class="n">contains</span> <span class="n">function</span> <span class="n">d</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">package</span>
<span class="n">package</span><span class="o">.</span><span class="n">a</span><span class="p">()</span>
<span class="n">package</span><span class="o">.</span><span class="n">b</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">package.other</span>
<span class="n">package</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">c</span><span class="p">()</span>

<span class="kn">import</span> <span class="nn">package.subdir</span>
<span class="n">package</span><span class="o">.</span><span class="n">subdir</span><span class="o">.</span><span class="n">d</span><span class="p">()</span>
</code></pre></div>

<p><em>note:</em> hierarchies of packages more than two deep are annoying to develop on</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">Docstrings</span>
<span class="sd">---------</span>

<span class="sd">&quot;Good&quot; docstring coding is used to provide additional information about functionality </span>
<span class="sd">beyond what can be discovered automatically by introspection</span>
<span class="sd">&quot;&quot;&quot;</span>
</code></pre></div>

<h3>testing, testing, testing...</h3>
<p><strong>An Introduction to Testing Concepts</strong></p>
<p>Unit tests are tests for fairly small and specific units of functionality.
Functional tests test entire functional paths through your code. 
Regression tests make sure that (within the resolution of your records) your program's output has not changed.</p>
<p>All three types of tests are necessary in different ways.</p>
<p>Regression tests tell you when unexpected changes in behavior occur, and can
reassure you that your basic data processing is still working.  For scientists,
this is particularly important if you are trying to link past research results
to new research results: if you can no longer replicate your original results
with your updated code, then you must regard your code with suspicion, unless
the changes are intentional.</p>
<p>Both unit and functional tests tend to be expectation based.  you use the tests
to lay out what behavior you expect from your code, and write your tests so
that they assert that those expectations are met.</p>
<p>Unit tests tend to be much shorter and require less setup and teardown, while
functional tests can be quite long.  functional tests tell you when your code
is broken, while unit tests tell you where your code is broken.  because of the
finer granularity of unit tests, a broken unit test can identify a particular
piece of code as the source of an error, while functional tests merely tell you
that a feature is broken.</p>
<h3>Adding tests to existing project</h3>
<p>First, start by writing a test for each bug as they are discovered.
isolate the cause of the bug; write a test that demonstrates the bug; fix the
bug; verify that the test passes.</p>
<p>Next, take out some time -- half a day or so -- and write fixtures and
functional tests for some small chunk of code; if you can, pick a piece of code
that you're planning to clean up or extend. Don't worry about being exhaustive,
just write tests that target the main point of the code that you're working on.</p>
<p>Repeat this a few times. </p>
<p>Use code coverage analysis to analyze what code your tests cover, and what code
isn't covered.  At this point you can take a targetted approach and spend some
time writing tests aimed directly at uncovered areas of code.  There should now
be tests that cover 30-50% of your code, at least (it's very easy to attain
this level of code coverage!).</p>
<p>Once you've reached this point, you can either decide to focus on increasing
your code coverage, or you can simply continue incrementally constraining your
code by writing tests for bugs and new features.  Assuming you have a fairly
normal code churn, you should get to the point of 70-80% coverage within a few
months to a few years (depending on the size of the project!)</p>
<p><strong>Cache decorator</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">simple_cache</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">new_fn</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;FOUND IN CACHE; RETURNING&#39;</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="c1"># otherwise, call function &amp; record value</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">new_fn</span>
<span class="nd">@simplecache</span>
<span class="n">f</span><span class="p">()</span>
</code></pre></div>

<p>This approach is effective because at each stage you get immediate feedback
from your efforts, and it's easier to justify to managers than a whole-team
effort to add testing. Plus, if you're unfamiliar with testing or with parts of
the code base, it gives you time to adjust and adapt your approach to the needs
of the particular project.</p>
<hr>
<p>see also: </p>
<ul>
<li><a href="https://www.youtube.com/watch?v=_O23jIXsshs">10 tips for pythonic code</a></li>
<li><a href="https://github.com/mikeckennedy/ten-tips-for-pythonic-code-jetbrains-webcast/blob/master/">ten-tips-for-pythonic-coten-tips-for-pythonic-code</a></li>
</ul></article>



        </main> 

        <footer>
                <p>&mdash; &centerdot; &centerdot; &centerdot;</p> 
                <!---
                <a href='/about'>about</a> &compfn;
                <a href='#'>book</a> &compfn;
                <a href="mailto:nehemiahcampbell@hotmail.co.uk">contact</a>
                -->
        </footer>

            </div>
    </body>
</html>
